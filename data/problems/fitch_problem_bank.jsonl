{"id": "entailment_001", "premises": ["Q", "((Q | R) -> S)"], "conclusion": "(S & S)", "difficulty": {"depth": 2, "length": 3}, "ascii_solution": "```\n1 | Q                    Pr\n2 | ((Q ∨ R) → S)        Pr\n3 | (Q ∨ R)              ∨I 1\n4 | S                    →E 2, 3\n5 | (S ∧ S)              ∧I 4, 4\n```", "json_solution": {"premises": ["Q", "((Q | R) → S)"], "conclusion": "(S ∧ S)", "solution": [{"formula": "Q", "justification": "Pr", "assumeno": 0}, {"formula": "((Q ∨ R) → S)", "justification": "Pr", "assumeno": 0}, {"formula": "(Q ∨ R)", "justification": "∨I 1", "assumeno": 0}, {"formula": "S", "justification": "→E 2, 3", "assumeno": 0}, {"formula": "(S ∧ S)", "justification": "∧I 4, 4", "assumeno": 0}]}, "metadata": {"line_count": 7, "rules_used": ["→E", "∧I", "∨I"], "subproof_depth": 0, "total_steps": 5}, "validation_result": {"valid": true, "issues": [], "concReached": true, "raw_output": "Reading file: C:\\Users\\seber\\AppData\\Local\\Temp\\tmpjp04w6qb.json\n\n=== INPUT FLAT PROOF ===\nLine 1: assumeno=0, formula='Q', just='Pr'\nLine 2: assumeno=0, formula='((Q ∨ R) → S)', just='Pr'\nLine 3: assumeno=0, formula='(Q ∨ R)', just='∨I 1'\nLine 4: assumeno=0, formula='S', just='→E 2, 3'\nLine 5: assumeno=0, formula='(S ∧ S)', just='∧I 4, 4'\n\n=== CONVERSION DEBUG ===\n\n[Line 1] depth=0, formula='Q', just='Pr'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 2] depth=0, formula='((Q ∨ R) → S)', just='Pr'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 3] depth=0, formula='(Q ∨ R)', just='∨I 1'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 4] depth=0, formula='S', just='→E 2, 3'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 5] depth=0, formula='(S ∧ S)', just='∧I 4, 4'\n  Stack size before: 1\n  Stack size after: 1\n\n=== FINAL NESTED STRUCTURE ===\nArray\n(\n    [0] => stdClass Object\n        (\n            [wffstr] => Q\n            [jstr] => Pr\n        )\n\n    [1] => stdClass Object\n        (\n            [wffstr] => ((Q ∨ R) → S)\n            [jstr] => Pr\n        )\n\n    [2] => stdClass Object\n        (\n            [wffstr] => (Q ∨ R)\n            [jstr] => ∨I 1\n        )\n\n    [3] => stdClass Object\n        (\n            [wffstr] => S\n            [jstr] => →E 2, 3\n        )\n\n    [4] => stdClass Object\n        (\n            [wffstr] => (S ∧ S)\n            [jstr] => ∧I 4, 4\n        )\n\n)\n\n=== RUNNING CHECKER ===\nPremises: Q, ((Q | R) → S)\nConclusion: (S ∧ S)\n\n=== CHECKER RESULT ===\n✓ VALID\n"}, "solved_at": "2025-10-23T10:03:03.593644", "model_used": "deepseek/deepseek-chat", "condition_used": "protocol"}
{"id": "entailment_002", "premises": ["(S -> (Q & P))", "S"], "conclusion": "P", "difficulty": {"depth": 2, "length": 3}, "ascii_solution": "```\n1 | (S → (Q ∧ P))        Pr\n2 | S                    Pr\n3 | (Q ∧ P)              →E 1, 2\n4 | P                    ∧E 3\n```", "json_solution": {"premises": ["(S → (Q ∧ P))", "S"], "conclusion": "P", "solution": [{"formula": "(S → (Q ∧ P))", "justification": "Pr", "assumeno": 0}, {"formula": "S", "justification": "Pr", "assumeno": 0}, {"formula": "(Q ∧ P)", "justification": "→E 1, 2", "assumeno": 0}, {"formula": "P", "justification": "∧E 3", "assumeno": 0}]}, "metadata": {"line_count": 6, "rules_used": ["∧E", "→E"], "subproof_depth": 0, "total_steps": 4}, "validation_result": {"valid": true, "issues": [], "concReached": true, "raw_output": "Reading file: C:\\Users\\seber\\AppData\\Local\\Temp\\tmplgc3n6vf.json\n\n=== INPUT FLAT PROOF ===\nLine 1: assumeno=0, formula='(S → (Q ∧ P))', just='Pr'\nLine 2: assumeno=0, formula='S', just='Pr'\nLine 3: assumeno=0, formula='(Q ∧ P)', just='→E 1, 2'\nLine 4: assumeno=0, formula='P', just='∧E 3'\n\n=== CONVERSION DEBUG ===\n\n[Line 1] depth=0, formula='(S → (Q ∧ P))', just='Pr'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 2] depth=0, formula='S', just='Pr'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 3] depth=0, formula='(Q ∧ P)', just='→E 1, 2'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 4] depth=0, formula='P', just='∧E 3'\n  Stack size before: 1\n  Stack size after: 1\n\n=== FINAL NESTED STRUCTURE ===\nArray\n(\n    [0] => stdClass Object\n        (\n            [wffstr] => (S → (Q ∧ P))\n            [jstr] => Pr\n        )\n\n    [1] => stdClass Object\n        (\n            [wffstr] => S\n            [jstr] => Pr\n        )\n\n    [2] => stdClass Object\n        (\n            [wffstr] => (Q ∧ P)\n            [jstr] => →E 1, 2\n        )\n\n    [3] => stdClass Object\n        (\n            [wffstr] => P\n            [jstr] => ∧E 3\n        )\n\n)\n\n=== RUNNING CHECKER ===\nPremises: (S → (Q ∧ P)), S\nConclusion: P\n\n=== CHECKER RESULT ===\n✓ VALID\n"}, "solved_at": "2025-10-23T10:03:13.688796", "model_used": "deepseek/deepseek-chat", "condition_used": "protocol"}
{"id": "entailment_005", "premises": ["((S | P) & (R -> P))", "R"], "conclusion": "((P -> S) -> P)", "difficulty": {"depth": 2, "length": 3}, "ascii_solution": "```\n1 | ((S ∨ P) ∧ (R → P))  Pr\n2 | R                    Pr\n  |------------------------\n3 | (S ∨ P)              ∧E 1\n4 | (R → P)              ∧E 1\n5 | P                    →E 4, 2\n  |------------------------\n6 |  | (P → S)           Hyp\n  |  |--------------------\n7 |  | P                 R 5\n  |\n8 | ((P → S) → P)        →I 6-7\n```", "json_solution": {"premises": ["((S | P) ∧ (R → P))", "R"], "conclusion": "((P → S) → P)", "solution": [{"formula": "((S ∨ P) ∧ (R → P))", "justification": "Pr", "assumeno": 0}, {"formula": "R", "justification": "Pr", "assumeno": 0}, {"formula": "(S ∨ P)", "justification": "∧E 1", "assumeno": 0}, {"formula": "(R → P)", "justification": "∧E 1", "assumeno": 0}, {"formula": "P", "justification": "→E 4, 2", "assumeno": 0}, {"formula": "(P → S)", "justification": "Hyp", "assumeno": 1}, {"formula": "P", "justification": "R 5", "assumeno": 1}, {"formula": "((P → S) → P)", "justification": "→I 6-7", "assumeno": 0}]}, "metadata": {"line_count": 14, "rules_used": ["∧E", "→I", "→E"], "subproof_depth": 1, "total_steps": 8}, "validation_result": {"valid": true, "issues": [], "concReached": true, "raw_output": "Reading file: C:\\Users\\seber\\AppData\\Local\\Temp\\tmphzitjlfd.json\n\n=== INPUT FLAT PROOF ===\nLine 1: assumeno=0, formula='((S ∨ P) ∧ (R → P))', just='Pr'\nLine 2: assumeno=0, formula='R', just='Pr'\nLine 3: assumeno=0, formula='(S ∨ P)', just='∧E 1'\nLine 4: assumeno=0, formula='(R → P)', just='∧E 1'\nLine 5: assumeno=0, formula='P', just='→E 4, 2'\nLine 6: assumeno=1, formula='(P → S)', just='Hyp'\nLine 7: assumeno=1, formula='P', just='R 5'\nLine 8: assumeno=0, formula='((P → S) → P)', just='→I 6-7'\n\n=== CONVERSION DEBUG ===\n\n[Line 1] depth=0, formula='((S ∨ P) ∧ (R → P))', just='Pr'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 2] depth=0, formula='R', just='Pr'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 3] depth=0, formula='(S ∨ P)', just='∧E 1'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 4] depth=0, formula='(R → P)', just='∧E 1'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 5] depth=0, formula='P', just='→E 4, 2'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 6] depth=1, formula='(P → S)', just='Hyp'\n  Stack size before: 1\n  ACTION: Creating new subproof\n  Stack size after: 2\n\n[Line 7] depth=1, formula='P', just='R 5'\n  Stack size before: 2\n  Stack size after: 2\n\n[Line 8] depth=0, formula='((P → S) → P)', just='→I 6-7'\n  Stack size before: 2\n  ACTION: Going shallower (pop 1 levels)\n  Stack size after: 1\n\n=== FINAL NESTED STRUCTURE ===\nArray\n(\n    [0] => stdClass Object\n        (\n            [wffstr] => ((S ∨ P) ∧ (R → P))\n            [jstr] => Pr\n        )\n\n    [1] => stdClass Object\n        (\n            [wffstr] => R\n            [jstr] => Pr\n        )\n\n    [2] => stdClass Object\n        (\n            [wffstr] => (S ∨ P)\n            [jstr] => ∧E 1\n        )\n\n    [3] => stdClass Object\n        (\n            [wffstr] => (R → P)\n            [jstr] => ∧E 1\n        )\n\n    [4] => stdClass Object\n        (\n            [wffstr] => P\n            [jstr] => →E 4, 2\n        )\n\n    [5] => Array\n        (\n            [0] => stdClass Object\n                (\n                    [wffstr] => (P → S)\n                    [jstr] => Hyp\n                )\n\n            [1] => stdClass Object\n                (\n                    [wffstr] => P\n                    [jstr] => R 5\n                )\n\n        )\n\n    [6] => stdClass Object\n        (\n            [wffstr] => ((P → S) → P)\n            [jstr] => →I 6-7\n        )\n\n)\n\n=== RUNNING CHECKER ===\nPremises: ((S | P) ∧ (R → P)), R\nConclusion: ((P → S) → P)\n\n=== CHECKER RESULT ===\n✓ VALID\n"}, "solved_at": "2025-10-23T10:04:49.194559", "model_used": "deepseek/deepseek-chat", "condition_used": "protocol"}
{"id": "entailment_006", "premises": ["P", "((P | S) -> (R & Q))"], "conclusion": "R", "difficulty": {"depth": 2, "length": 3}, "ascii_solution": "```\n1 | P                    Pr\n2 | ((P ∨ S) → (R ∧ Q))  Pr\n3 | (P ∨ S)              ∨I 1\n4 | (R ∧ Q)              →E 2, 3\n5 | R                    ∧E 4\n```", "json_solution": {"premises": ["P", "((P | S) → (R ∧ Q))"], "conclusion": "R", "solution": [{"formula": "P", "justification": "Pr", "assumeno": 0}, {"formula": "((P ∨ S) → (R ∧ Q))", "justification": "Pr", "assumeno": 0}, {"formula": "(P ∨ S)", "justification": "∨I 1", "assumeno": 0}, {"formula": "(R ∧ Q)", "justification": "→E 2, 3", "assumeno": 0}, {"formula": "R", "justification": "∧E 4", "assumeno": 0}]}, "metadata": {"line_count": 7, "rules_used": ["∧E", "→E", "∨I"], "subproof_depth": 0, "total_steps": 5}, "validation_result": {"valid": true, "issues": [], "concReached": true, "raw_output": "Reading file: C:\\Users\\seber\\AppData\\Local\\Temp\\tmp4v7wrh75.json\n\n=== INPUT FLAT PROOF ===\nLine 1: assumeno=0, formula='P', just='Pr'\nLine 2: assumeno=0, formula='((P ∨ S) → (R ∧ Q))', just='Pr'\nLine 3: assumeno=0, formula='(P ∨ S)', just='∨I 1'\nLine 4: assumeno=0, formula='(R ∧ Q)', just='→E 2, 3'\nLine 5: assumeno=0, formula='R', just='∧E 4'\n\n=== CONVERSION DEBUG ===\n\n[Line 1] depth=0, formula='P', just='Pr'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 2] depth=0, formula='((P ∨ S) → (R ∧ Q))', just='Pr'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 3] depth=0, formula='(P ∨ S)', just='∨I 1'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 4] depth=0, formula='(R ∧ Q)', just='→E 2, 3'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 5] depth=0, formula='R', just='∧E 4'\n  Stack size before: 1\n  Stack size after: 1\n\n=== FINAL NESTED STRUCTURE ===\nArray\n(\n    [0] => stdClass Object\n        (\n            [wffstr] => P\n            [jstr] => Pr\n        )\n\n    [1] => stdClass Object\n        (\n            [wffstr] => ((P ∨ S) → (R ∧ Q))\n            [jstr] => Pr\n        )\n\n    [2] => stdClass Object\n        (\n            [wffstr] => (P ∨ S)\n            [jstr] => ∨I 1\n        )\n\n    [3] => stdClass Object\n        (\n            [wffstr] => (R ∧ Q)\n            [jstr] => →E 2, 3\n        )\n\n    [4] => stdClass Object\n        (\n            [wffstr] => R\n            [jstr] => ∧E 4\n        )\n\n)\n\n=== RUNNING CHECKER ===\nPremises: P, ((P | S) → (R ∧ Q))\nConclusion: R\n\n=== CHECKER RESULT ===\n✓ VALID\n"}, "solved_at": "2025-10-23T10:05:00.573346", "model_used": "deepseek/deepseek-chat", "condition_used": "protocol"}
{"id": "entailment_007", "premises": ["P", "((P | Q) -> Q)"], "conclusion": "Q", "difficulty": {"depth": 2, "length": 3}, "ascii_solution": "```\n1 | P                    Pr\n2 | ((P ∨ Q) → Q)        Pr\n3 | (P ∨ Q)              ∨I 1\n4 | Q                    →E 2, 3\n```", "json_solution": {"premises": ["P", "((P | Q) → Q)"], "conclusion": "Q", "solution": [{"formula": "P", "justification": "Pr", "assumeno": 0}, {"formula": "((P ∨ Q) → Q)", "justification": "Pr", "assumeno": 0}, {"formula": "(P ∨ Q)", "justification": "∨I 1", "assumeno": 0}, {"formula": "Q", "justification": "→E 2, 3", "assumeno": 0}]}, "metadata": {"line_count": 6, "rules_used": ["→E", "∨I"], "subproof_depth": 0, "total_steps": 4}, "validation_result": {"valid": true, "issues": [], "concReached": true, "raw_output": "Reading file: C:\\Users\\seber\\AppData\\Local\\Temp\\tmpqozwjo1g.json\n\n=== INPUT FLAT PROOF ===\nLine 1: assumeno=0, formula='P', just='Pr'\nLine 2: assumeno=0, formula='((P ∨ Q) → Q)', just='Pr'\nLine 3: assumeno=0, formula='(P ∨ Q)', just='∨I 1'\nLine 4: assumeno=0, formula='Q', just='→E 2, 3'\n\n=== CONVERSION DEBUG ===\n\n[Line 1] depth=0, formula='P', just='Pr'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 2] depth=0, formula='((P ∨ Q) → Q)', just='Pr'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 3] depth=0, formula='(P ∨ Q)', just='∨I 1'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 4] depth=0, formula='Q', just='→E 2, 3'\n  Stack size before: 1\n  Stack size after: 1\n\n=== FINAL NESTED STRUCTURE ===\nArray\n(\n    [0] => stdClass Object\n        (\n            [wffstr] => P\n            [jstr] => Pr\n        )\n\n    [1] => stdClass Object\n        (\n            [wffstr] => ((P ∨ Q) → Q)\n            [jstr] => Pr\n        )\n\n    [2] => stdClass Object\n        (\n            [wffstr] => (P ∨ Q)\n            [jstr] => ∨I 1\n        )\n\n    [3] => stdClass Object\n        (\n            [wffstr] => Q\n            [jstr] => →E 2, 3\n        )\n\n)\n\n=== RUNNING CHECKER ===\nPremises: P, ((P | Q) → Q)\nConclusion: Q\n\n=== CHECKER RESULT ===\n✓ VALID\n"}, "solved_at": "2025-10-23T10:05:11.927243", "model_used": "deepseek/deepseek-chat", "condition_used": "protocol"}
{"id": "entailment_009", "premises": ["Q", "R"], "conclusion": "((R -> P) -> (Q & R))", "difficulty": {"depth": 2, "length": 3}, "ascii_solution": "```\n1 | Q                    Pr\n2 | R                    Pr\n  |------------------------\n3 |  | (R → P)           Hyp\n  |  |--------------------\n4 |  | Q                 R 1\n5 |  | R                 R 2\n6 |  | (Q ∧ R)           ∧I 4, 5\n  |\n7 | ((R → P) → (Q ∧ R))  →I 3-6\n```", "json_solution": {"premises": ["Q", "R"], "conclusion": "((R → P) → (Q ∧ R))", "solution": [{"formula": "Q", "justification": "Pr", "assumeno": 0}, {"formula": "R", "justification": "Pr", "assumeno": 0}, {"formula": "(R → P)", "justification": "Hyp", "assumeno": 1}, {"formula": "Q", "justification": "R 1", "assumeno": 1}, {"formula": "R", "justification": "R 2", "assumeno": 1}, {"formula": "(Q ∧ R)", "justification": "∧I 4, 5", "assumeno": 1}, {"formula": "((R → P) → (Q ∧ R))", "justification": "→I 3-6", "assumeno": 0}]}, "metadata": {"line_count": 12, "rules_used": ["∧I", "→I"], "subproof_depth": 1, "total_steps": 7}, "validation_result": {"valid": true, "issues": [], "concReached": true, "raw_output": "Reading file: C:\\Users\\seber\\AppData\\Local\\Temp\\tmpnfgyives.json\n\n=== INPUT FLAT PROOF ===\nLine 1: assumeno=0, formula='Q', just='Pr'\nLine 2: assumeno=0, formula='R', just='Pr'\nLine 3: assumeno=1, formula='(R → P)', just='Hyp'\nLine 4: assumeno=1, formula='Q', just='R 1'\nLine 5: assumeno=1, formula='R', just='R 2'\nLine 6: assumeno=1, formula='(Q ∧ R)', just='∧I 4, 5'\nLine 7: assumeno=0, formula='((R → P) → (Q ∧ R))', just='→I 3-6'\n\n=== CONVERSION DEBUG ===\n\n[Line 1] depth=0, formula='Q', just='Pr'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 2] depth=0, formula='R', just='Pr'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 3] depth=1, formula='(R → P)', just='Hyp'\n  Stack size before: 1\n  ACTION: Creating new subproof\n  Stack size after: 2\n\n[Line 4] depth=1, formula='Q', just='R 1'\n  Stack size before: 2\n  Stack size after: 2\n\n[Line 5] depth=1, formula='R', just='R 2'\n  Stack size before: 2\n  Stack size after: 2\n\n[Line 6] depth=1, formula='(Q ∧ R)', just='∧I 4, 5'\n  Stack size before: 2\n  Stack size after: 2\n\n[Line 7] depth=0, formula='((R → P) → (Q ∧ R))', just='→I 3-6'\n  Stack size before: 2\n  ACTION: Going shallower (pop 1 levels)\n  Stack size after: 1\n\n=== FINAL NESTED STRUCTURE ===\nArray\n(\n    [0] => stdClass Object\n        (\n            [wffstr] => Q\n            [jstr] => Pr\n        )\n\n    [1] => stdClass Object\n        (\n            [wffstr] => R\n            [jstr] => Pr\n        )\n\n    [2] => Array\n        (\n            [0] => stdClass Object\n                (\n                    [wffstr] => (R → P)\n                    [jstr] => Hyp\n                )\n\n            [1] => stdClass Object\n                (\n                    [wffstr] => Q\n                    [jstr] => R 1\n                )\n\n            [2] => stdClass Object\n                (\n                    [wffstr] => R\n                    [jstr] => R 2\n                )\n\n            [3] => stdClass Object\n                (\n                    [wffstr] => (Q ∧ R)\n                    [jstr] => ∧I 4, 5\n                )\n\n        )\n\n    [3] => stdClass Object\n        (\n            [wffstr] => ((R → P) → (Q ∧ R))\n            [jstr] => →I 3-6\n        )\n\n)\n\n=== RUNNING CHECKER ===\nPremises: Q, R\nConclusion: ((R → P) → (Q ∧ R))\n\n=== CHECKER RESULT ===\n✓ VALID\n"}, "solved_at": "2025-10-23T10:05:49.696588", "model_used": "deepseek/deepseek-chat", "condition_used": "protocol"}
{"id": "entailment_010", "premises": ["P", "((P | P) -> (Q | Q))"], "conclusion": "Q", "difficulty": {"depth": 2, "length": 3}, "ascii_solution": "```\n1 | P                    Pr\n2 | ((P ∨ P) → (Q ∨ Q))  Pr\n3 | (P ∨ P)              ∨I 1\n4 | (Q ∨ Q)              →E 2, 3\n  |------------------------\n5 |  | Q                 Hyp\n  |  |--------------------\n6 |  | Q                 R 5\n  |\n7 |  | Q                 Hyp\n  |  |--------------------\n8 |  | Q                 R 7\n  |\n9 | Q                    ∨E 4, 5-6, 7-8\n```", "json_solution": {"premises": ["P", "((P | P) → (Q | Q))"], "conclusion": "Q", "solution": [{"formula": "P", "justification": "Pr", "assumeno": 0}, {"formula": "((P ∨ P) → (Q ∨ Q))", "justification": "Pr", "assumeno": 0}, {"formula": "(P ∨ P)", "justification": "∨I 1", "assumeno": 0}, {"formula": "(Q ∨ Q)", "justification": "→E 2, 3", "assumeno": 0}, {"formula": "Q", "justification": "Hyp", "assumeno": 1}, {"formula": "Q", "justification": "R 5", "assumeno": 1}, {"formula": "Q", "justification": "Hyp", "assumeno": 1}, {"formula": "Q", "justification": "R 7", "assumeno": 1}, {"formula": "Q", "justification": "∨E 4, 5-6, 7-8", "assumeno": 0}]}, "metadata": {"line_count": 16, "rules_used": ["→E", "∨I", "∨E"], "subproof_depth": 1, "total_steps": 9}, "validation_result": {"valid": true, "issues": [], "concReached": true, "raw_output": "Reading file: C:\\Users\\seber\\AppData\\Local\\Temp\\tmptcecifxy.json\n\n=== INPUT FLAT PROOF ===\nLine 1: assumeno=0, formula='P', just='Pr'\nLine 2: assumeno=0, formula='((P ∨ P) → (Q ∨ Q))', just='Pr'\nLine 3: assumeno=0, formula='(P ∨ P)', just='∨I 1'\nLine 4: assumeno=0, formula='(Q ∨ Q)', just='→E 2, 3'\nLine 5: assumeno=1, formula='Q', just='Hyp'\nLine 6: assumeno=1, formula='Q', just='R 5'\nLine 7: assumeno=1, formula='Q', just='Hyp'\nLine 8: assumeno=1, formula='Q', just='R 7'\nLine 9: assumeno=0, formula='Q', just='∨E 4, 5-6, 7-8'\n\n=== CONVERSION DEBUG ===\n\n[Line 1] depth=0, formula='P', just='Pr'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 2] depth=0, formula='((P ∨ P) → (Q ∨ Q))', just='Pr'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 3] depth=0, formula='(P ∨ P)', just='∨I 1'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 4] depth=0, formula='(Q ∨ Q)', just='→E 2, 3'\n  Stack size before: 1\n  Stack size after: 1\n\n[Line 5] depth=1, formula='Q', just='Hyp'\n  Stack size before: 1\n  ACTION: Creating new subproof\n  Stack size after: 2\n\n[Line 6] depth=1, formula='Q', just='R 5'\n  Stack size before: 2\n  Stack size after: 2\n\n[Line 7] depth=1, formula='Q', just='Hyp'\n  Stack size before: 2\n  ACTION: Sibling subproof detected (pop to parent)\n  ACTION: Creating new subproof\n  Stack size after: 2\n\n[Line 8] depth=1, formula='Q', just='R 7'\n  Stack size before: 2\n  Stack size after: 2\n\n[Line 9] depth=0, formula='Q', just='∨E 4, 5-6, 7-8'\n  Stack size before: 2\n  ACTION: Going shallower (pop 1 levels)\n  Stack size after: 1\n\n=== FINAL NESTED STRUCTURE ===\nArray\n(\n    [0] => stdClass Object\n        (\n            [wffstr] => P\n            [jstr] => Pr\n        )\n\n    [1] => stdClass Object\n        (\n            [wffstr] => ((P ∨ P) → (Q ∨ Q))\n            [jstr] => Pr\n        )\n\n    [2] => stdClass Object\n        (\n            [wffstr] => (P ∨ P)\n            [jstr] => ∨I 1\n        )\n\n    [3] => stdClass Object\n        (\n            [wffstr] => (Q ∨ Q)\n            [jstr] => →E 2, 3\n        )\n\n    [4] => Array\n        (\n            [0] => stdClass Object\n                (\n                    [wffstr] => Q\n                    [jstr] => Hyp\n                )\n\n            [1] => stdClass Object\n                (\n                    [wffstr] => Q\n                    [jstr] => R 5\n                )\n\n        )\n\n    [5] => Array\n        (\n            [0] => stdClass Object\n                (\n                    [wffstr] => Q\n                    [jstr] => Hyp\n                )\n\n            [1] => stdClass Object\n                (\n                    [wffstr] => Q\n                    [jstr] => R 7\n                )\n\n        )\n\n    [6] => stdClass Object\n        (\n            [wffstr] => Q\n            [jstr] => ∨E 4, 5-6, 7-8\n        )\n\n)\n\n=== RUNNING CHECKER ===\nPremises: P, ((P | P) → (Q | Q))\nConclusion: Q\n\n=== CHECKER RESULT ===\n✓ VALID\n"}, "solved_at": "2025-10-23T10:06:07.458710", "model_used": "deepseek/deepseek-chat", "condition_used": "protocol"}
